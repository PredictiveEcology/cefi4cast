{
  "hash": "e3972f95efdb29de17e1f0755f921011",
  "result": {
    "markdown": "---\ntitle: \"Is `R` Fast Enough? - Part 4 - 'Loops'\"\nauthor: Eliot McIntire\ndate: May 12, 2015\ncategories: [R, benchmark]\ncomments: false\n---\n\n\nIn part 4 of this series on benchmarking `R`, we'll explore loops and a common alternative, vectorizing. This is probably the \"biggest\" issue making people think that R is a slow language. Essentially, other procedural languages use explicit loops; programmers moving from those languages to R start with the same procedures and find that R is slow. We will discuss a range of ways making loops faster and how vectorizing can help. \n\nThere are many other resources about this topic; we will try to be concise and show the worst case, the best case, and many little steps in between.\n\n\n## Loops\n\nLoops have been the achilles heel of R in the past. In version 3.1 and forward, much of this problem appears to be gone. As could be seen in the [https://predictiveecology.org/2015/05/06/Is-R-fast-enough-03.html](Fibonacci  example), pre-allocating a vector and filling it up inside a loop can now be very fast and efficient in native R. To demonstrate these points, below are 6 ways to achieve the same result in R, beginning with a naive loop approach, and working up to the fully vectorized approach. I am using a very fast vectorized function, seq_len, to emphasize the differences between using loops and optimized vectorized functions.\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\nThe basic code below generates random numbers. The sequence goes from a fully unvectorized, looped structure, with no pre-allocation of the output vector, through to pure vectorized code. The intermediate steps are:\n\n- Loop\n- Loop with pre-allocated length of output\n- sapply (like loops)\n- sapply with pipe operator\n- vectorized\n- vectorized with no intermediate objects\n- C++ vectorized\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(magrittr) # for pipe %>%\nN = 1e5\n\nmb = microbenchmark::microbenchmark(times=100L,\n\n                                     \n# no pre-allocating of vector length, generating uniform random numbers once, then calling them within each loop\nloopWithNoPreallocate = {\n  set.seed(104)\n  a <- numeric()\n  unifs = runif(N)\n    for (i in 1:N) {\n      a[i] = unifs[i]\n    } \n   a\n  } ,\n\n# pre-allocating vector length, generating uniform random numbers once, then calling them within each loop\nloopWithPreallocate = {\n    set.seed(104)\n    unifs <- runif(N)\n    b <- numeric(N) \n    for (i in 1:N) {\n      b[i] = unifs[i]\n    }\n    b\n  },\n \n# # sapply - generally faster than loops\nsapplyVector1 = {\n      set.seed(104)\n      b <- runif(N) \n      sapply(b,function(x) x)\n      },\n\n# sapply with pipe operator: no intermediate objects are created\nsapplyWithPipe = {\n      set.seed(104)\n      b <- (runif(N)) %>%\n        sapply(.,function(x) x)\n      },\n\n# vectorized with intermediate object before return\nvectorizedWithCopy = {\n    set.seed(104)\n    unifs <- runif(N)\n    unifs\n  },\n\n# no intermediate object before return\nvectorizedWithNoCopy = {\n  set.seed(104)\n  runif(N)\n  }\n\n)\n\nsummary(mb)[c(1,2,5,7)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   expr     min   median      max\n1 loopWithNoPreallocate 21.9615 29.84165  89.6070\n2   loopWithPreallocate  7.6051  8.09575  16.7365\n3         sapplyVector1 55.2273 61.30605 111.2397\n4        sapplyWithPipe 52.7653 58.97110 115.2396\n5    vectorizedWithCopy  2.0667  2.21285   6.6799\n6  vectorizedWithNoCopy  2.0717  2.22310   6.0343\n```\n:::\n\n```{.r .cell-code}\n# Test that all results return the same vector\nall.equalV(loopWithNoPreallocate, loopWithPreallocate, sapplyVector1, sapplyWithPipe, vectorizedWithCopy, vectorizedWithNoCopy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nsumLoops <- round(summary(mb)[[5]],0)\n```\n:::\n\n\nThe fully vectorized function is ***15x*** faster than the fully naive loop. Note also that making as few intermediate objects as possible is faster as well. Comparing vectorizedWithCopy and vectorizedWithNoCopy (where the only difference is making one copy of the object) shows virtually no change. This, I believe, is due to some improvements in after version 3.1 of R that reduces copying for vectors and matrices. Using pipes instead of intermediate objects also did not change the speed very much (slight change by 100%). These are simple tests, and for larger, or more complex objects, in general, it is likely that using pipes will be faster.\n\n## Conclusions\n\n***Write vectorized code in R*** where possible. If not possible, pre-allocate prior to writing loops. \n  \n\n#### Next time \n\nWe move on to higher level operations. Specifically, some GIS operations.\n\n\n--------------------\n\n#### Functions used\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equalV = function(...) {\n  vals <- list(...)\n  all(sapply(vals[-1], function(x) all.equal(vals[[1]], x)))\n}\n```\n:::\n\n\n#### System used:\nTests were done on an HP Z400, Xeon 3.33 GHz processor, running Windows 7 Enterprise, using:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.0 (2023-04-21 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 10 x64 (build 18363)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_Canada.utf8  LC_CTYPE=English_Canada.utf8   \n[3] LC_MONETARY=English_Canada.utf8 LC_NUMERIC=C                   \n[5] LC_TIME=English_Canada.utf8    \n\ntime zone: America/Vancouver\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] magrittr_2.0.3\n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.2     microbenchmark_1.4.10 compiler_4.3.0       \n [4] fastmap_1.1.1         cli_3.6.1             tools_4.3.0          \n [7] htmltools_0.5.5       rstudioapi_0.14       yaml_2.3.7           \n[10] rmarkdown_2.21        knitr_1.42            jsonlite_1.8.4       \n[13] xfun_0.39             digest_0.6.31         rlang_1.1.1          \n[16] evaluate_0.21        \n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}